# Padrão de Logger Java Avançado para Projetos

## Estrutura Recomendada

Sempre organize o logger em uma pasta `core/logger` com a seguinte estrutura:

```
core/
└── logger/
    ├── Console.java          # Constantes e separadores
    ├── ContextTime.java      # Medicao de tempo com ThreadLocal
    ├── LogFormatter.java     # Sistema avançado de formatacao
    ├── LogFileManager.java   # Gerenciamento de arquivos de log
    └── README.md            # Documentacao do padrão
```

## Boas Práticas Obrigatórias

### 1. Centralizacao e Padronizacao
- **NUNCA** use `System.out.println` diretamente no código
- **SEMPRE** utilize `LogFormatter.logStep()` para logs de steps
- **SEMPRE** utilize `LogFormatter.logStep()` para dados JSON
- Mantenha todos os logs padronizados e rastreáveis

### 2. Estrutura de Classes Avançada

#### Console.java (Constantes e Separadores)
```java
package core.logger;

public class Console {
    public static final String SEPARATE = "===========================================================================================";
    public static final String SEPARATE_HYPHEN = "------------------------------------------------------------------------------------";
    public static final String ID_TAG_NOT_FOUND = "[ID tag not found]";
    public static final String DATA_TAG_NOT_FOUND = "[Data tag not found]";
}
```

#### ContextTime.java (Medicao Avançada)
```java
package core.logger;

import java.time.LocalDateTime;

public class ContextTime {
    private static ThreadLocal<LocalDateTime> timeSuiteInit = new ThreadLocal<>();
    private static ThreadLocal<LocalDateTime> timeTestInit = new ThreadLocal<>();

    public static void printTimeInitial() {
        timeTestInit.set(LocalDateTime.now());
        LogFormatter.logStep("Initial hour of test: " + timeTestInit.get());
        
        if (timeSuiteInit.get() == null)
            timeSuiteInit.set(timeTestInit.get());
    }

    public static void printTimeFinal() {
        LocalDateTime timeTestFinal = LocalDateTime.now();
        LogFormatter.logStep("Final hour of test: " + timeTestFinal);
        
        // Calcular diferenças de tempo
        LogFormatter.logStep("Time execution of test: " + 
            returnDifferenceBetweenTimes(timeTestInit.get(), timeTestFinal));
    }
}
```

#### LogFormatter.java (Sistema Avançado)
```java
package core.logger;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LogFormatter {
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss.SSS");

    @Attachment(value = "Log do Step", type = "text/plain")
    public static String logStep(String message) {
        String timestamp = LocalDateTime.now().format(DATE_FORMATTER);
        String formattedMessage = String.format("%s INFO %s", timestamp, message);
        System.out.println(formattedMessage);
        LogFileManager.writeLog(formattedMessage);
        return formattedMessage;
    }

    @Attachment(value = "Log JSON", type = "application/json")
    public static String logStep(String data) {
        // Formatar JSON para ficar legível
        String prettyJson = formatJson(data);
        System.out.println(prettyJson);
        return prettyJson;
    }

    public static void logTestId(String testId) {
        String timestamp = LocalDateTime.now().format(DATE_FORMATTER);
        String formattedMessage = String.format("%s +--:| TestID: %s", timestamp, testId);
        System.out.println(formattedMessage);
        LogFileManager.writeLog(formattedMessage);
    }

    public static void logFeature(String featureName) {
        String timestamp = LocalDateTime.now().format(DATE_FORMATTER);
        String formattedMessage = String.format("%s INFO Feature: %s", timestamp, featureName);
        System.out.println(formattedMessage);
        LogFileManager.writeLog(formattedMessage);
    }
}
```

#### LogFileManager.java (Gerenciamento de Arquivos)
```java
package core.logger;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LogFileManager {
    private static final String LOG_DIR = "logs";
    private static final DateTimeFormatter FILE_DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static PrintWriter logWriter;

    static {
        createLogDirectory();
        initializeLogFile();
    }

    public static void writeLog(String message) {
        if (logWriter != null) {
            logWriter.println(message);
            logWriter.flush();
        }
    }

    public static void close() {
        if (logWriter != null) {
            logWriter.close();
        }
    }
}
```

### 3. Uso Padrão Avançado

```java
import core.logger.LogFormatter;
import core.logger.ContextTime;

public class ExemploUsoAvancado {
    public void executarTeste() {
        // Log de identificacao do teste
        LogFormatter.logTestId("test-123");
        
        // Log de feature
        LogFormatter.logFeature("Login do Sistema");
        
        // Início da medicao de tempo
        ContextTime.printTimeInitial();
        
        // Log de step com anexo no Allure
        LogFormatter.logStep("Iniciando processo de login");
        
        // Log de dados JSON
        LogFormatter.logStep("{\"user\": \"admin\", \"status\": \"success\"}");
        
        // Fim da medicao de tempo
        ContextTime.printTimeFinal();
    }
}
```

## Integracao com Frameworks

### Para Testes Automatizados (Cucumber/JUnit)
```java
@Given("que estou na pagina de login")
public void queEstouNaPaginaDeLogin() {
    LogFormatter.logStep("Navegando para pagina de login");
    // ... código do step
}

@When("preencho o campo {string} com {string}")
public void preenchoOCampoCom(String campo, String valor) {
    LogFormatter.logStep("Preenchendo campo " + campo + " com valor " + valor);
    // ... código do step
}
```

### Para APIs REST
```java
public void realizarRequisicao(String method, String url, String body) {
    LogFormatter.logRequest(method, url, body);
    // ... código da requisicao
    LogFormatter.logResponse("200", responseBody);
}
```

## Expansões Avançadas

### Logs Estruturados (JSON)
```java
public static void logStructured(String level, String message, Map<String, Object> context) {
    String jsonLog = String.format("""
        {
            "timestamp": "%s",
            "level": "%s",
            "message": "%s",
            "context": %s
        }""", LocalDateTime.now().format(DATE_FORMATTER), level, message, objectMapper.writeValueAsString(context));
    
    logStep(jsonLog);
}
```

### Logs de Performance
```java
public static void logPerformance(String operation, long durationMs) {
    LogFormatter.logStep(String.format("Performance: %s executado em %d ms", operation, durationMs));
}
```

### Logs de Contexto Thread-Safe
```java
public static void logWithContext(String context, String message) {
    String threadInfo = Thread.currentThread().getName();
    LogFormatter.logStep(String.format("[%s][%s] %s", threadInfo, context, message));
}
```

## Regras de Nomenclatura

- Classes: PascalCase (LogFormatter, ContextTime)
- Métodos: camelCase (logStep, logStep, printTimeInitial)
- Constantes: UPPER_SNAKE_CASE (SEPARATE, ID_TAG_NOT_FOUND)
- Pacotes: lowercase (core.logger)

## Regras Críticas para Relatórios Finais

### 1. Posicionamento do Relatório Final (CRÍTICO)
- **NUNCA** gerar relatório final no meio da execução
- **SEMPRE** aguardar TODOS os cenários terminarem
- **SEMPRE** usar ThreadLocal para controle de estado
- **SEMPRE** verificar se é realmente o último cenário

### 2. Implementação Obrigatória
```java
public class Hooks {
    private static ThreadLocal<Integer> executedScenarios = new ThreadLocal<>();
    private static ThreadLocal<Integer> totalScenarios = new ThreadLocal<>();
    private static ThreadLocal<Boolean> finalReportGenerated = new ThreadLocal<>();
    
    @Before
    public void beforeScenario(Scenario scenario) {
        if (executedScenarios.get() == null) {
            executedScenarios.set(0);
            totalScenarios.set(detectTotalScenarios(scenario));
            finalReportGenerated.set(false);
        }
        
        executedScenarios.set(executedScenarios.get() + 1);
    }
    
    @After
    public void afterScenario(Scenario scenario) {
        // NUNCA gerar relatório aqui - apenas contar
        if (scenario.isFailed()) {
            LogFormatter.incrementFailures();
        }
        
        // Verificar se é o último cenário REAL
        if (executedScenarios.get() >= totalScenarios.get() && !finalReportGenerated.get()) {
            finalReportGenerated.set(true);
            // Aguardar um pouco para garantir que todos os logs terminaram
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            LogFormatter.generateFinalReport();
        }
    }
}
```

### 3. Detecção Precisa do Total de Cenários
```java
private int detectTotalScenarios(Scenario scenario) {
    // SEMPRE contar cenários dinamicamente
    // NUNCA usar valores hardcoded
    try {
        String uri = scenario.getUri().toString();
        // Implementar lógica para contar cenários reais
        return countScenariosInFeature(uri);
    } catch (Exception e) {
        LogFormatter.logStep("Erro ao detectar total de cenários: " + e.getMessage());
        return 1; // Fallback seguro
    }
}
```

### 4. Controle de Estado Thread-Safe
```java
public class LogFormatter {
    private static ThreadLocal<Boolean> finalReportGenerated = new ThreadLocal<>();
    private static ThreadLocal<LocalDateTime> startTime = new ThreadLocal<>();
    private static ThreadLocal<LocalDateTime> endTime = new ThreadLocal<>();
    
    public static void generateFinalReport() {
        if (finalReportGenerated.get() != null && finalReportGenerated.get()) {
            return; // Já foi gerado
        }
        
        finalReportGenerated.set(true);
        endTime.set(LocalDateTime.now());
        
        // Garantir que o relatório seja o último item
        System.out.println("\n" + "=".repeat(80));
        printFinalReport();
        System.out.println("=".repeat(80) + "\n");
    }
}
```

### 5. Validação de Integridade
```java
public static void validateReportPosition() {
    // Verificar se o relatório final está no lugar correto
    if (finalReportGenerated.get() == null || !finalReportGenerated.get()) {
        LogFormatter.logStep("AVISO: Relatório final não foi gerado corretamente");
    }
}
```

## Configuracao de Dependências

### Maven (pom.xml)
```xml
<dependencies>
    <!-- SLF4J para logging -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>1.7.36</version>
    </dependency>
    
    <!-- Jackson para formatacao JSON -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
    </dependency>
    
    <!-- Allure para anexos -->
    <dependency>
        <groupId>io.qameta.allure</groupId>
        <artifactId>allure-java-commons</artifactId>
        <version>2.24.0</version>
    </dependency>
</dependencies>
```

## Migracao de Projetos Existentes

1. **Crie a estrutura `core/logger`**
2. **Implemente as classes avançadas** (LogFormatter, LogFileManager, ContextTime)
3. **Substitua logs básicos** por `LogFormatter.logStep()`
4. **Adicione logs JSON** com `LogFormatter.logStep()`
5. **Implemente medicao de tempo** com `ContextTime`
6. **Configure integracao Allure** para anexos automáticos
7. **Documente o padrão** para a equipe

## Exemplos de Uso por Contexto

### Testes de API
```java
LogFormatter.logRequest("POST", "/api/users", requestBody);
LogFormatter.logResponse("201", responseBody);
```

### Testes Web
```java
LogFormatter.logStep("Clicando no botao 'Salvar'");
LogFormatter.logStep("Validando mensagem de sucesso");
```

### Testes de Performance
```java
ContextTime.printTimeInitial();
// ... execucao do teste
ContextTime.printTimeFinal();
```

---

**Lembre-se**: Este padrão avançado garante logs estruturados, rastreáveis e integrados com relatórios, mantendo consistência em todos os projetos Java.
description:
globs:
alwaysApply: false
---
